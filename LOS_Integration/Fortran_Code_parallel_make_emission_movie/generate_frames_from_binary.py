#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
generate_frames_from_binary.py
==============================
Generate PNG Movie Frames from Fortran Binary Output

This script reads the binary emission data files generated by the MPI-parallelized
Fortran code (make_emission_movie_frames_mpi) and creates PNG image frames for
the movie.

INPUT FILES (in output_data/ directory):
    grid_info.bin           - Grid coordinates and metadata
    colorbar_limits.bin     - Colorbar limits for each emission line
    frame_XXXX_s1p_6731.bin - S+ 6731 Å emission data for each frame
    frame_XXXX_s2p_680.bin  - S++ 680 Å emission data for each frame
    frame_XXXX_op_833.bin   - O+ 833 Å emission data for each frame

OUTPUT:
    movie_frames/frames_stacked/frame_XXXX.png - Stacked 3-panel images

FRAME LAYOUT:
    Top panel:    S+ 6731 Å (Optical)
    Middle panel: S++ 680 Å (UV)
    Bottom panel: O+ 833 Å (UV)

USAGE:
    python generate_frames_from_binary.py

AUTHOR: Edward (Eddie) G. Nerney
INSTITUTION: Laboratory for Atmospheric and Space Physics, CU Boulder
LICENSE: Open source for academic and research use (MOP Community Code)
DATE: November 2025
"""

import numpy as np
import matplotlib.pyplot as plt
from pathlib import Path
import shutil
import sys


# =============================================================================
# CONFIGURATION
# =============================================================================

# Input/Output directories
INPUT_DIR = Path("output_data")
OUTPUT_BASE = Path("movie_frames")
FRAME_DIR = OUTPUT_BASE / "frames_stacked"

# Plot configuration
DPI = 200 #150
FIGSIZE = (12, 10)
COLORMAP = 'viridis'


# =============================================================================
# BINARY FILE READERS
# =============================================================================

def read_grid_info(filepath):
    """
    Read grid information from binary file.
    
    Parameters
    ----------
    filepath : Path
        Path to grid_info.bin
    
    Returns
    -------
    dict
        Dictionary containing:
        - nrho: Number of radial grid points
        - nz: Number of vertical grid points
        - rho_grid: Radial coordinates [R_J]
        - z_grid: Vertical coordinates [R_J]
        - n_frames: Total number of frames
        - s2p_680_vmax: Manual colorbar limit for S++ 680 Å
        - op_833_vmax: Manual colorbar limit for O+ 833 Å
    """
    with open(filepath, 'rb') as f:
        # Read grid dimensions (2 int32)
        nrho = np.fromfile(f, dtype=np.int32, count=1)[0]
        nz = np.fromfile(f, dtype=np.int32, count=1)[0]
        
        # Read grid arrays
        rho_grid = np.fromfile(f, dtype=np.float64, count=nrho)
        z_grid = np.fromfile(f, dtype=np.float64, count=nz)
        
        # Read frame count
        n_frames = np.fromfile(f, dtype=np.int32, count=1)[0]
        
        # Read UV colorbar limits
        s2p_680_vmax = np.fromfile(f, dtype=np.float64, count=1)[0]
        op_833_vmax = np.fromfile(f, dtype=np.float64, count=1)[0]
    
    return {
        'nrho': nrho,
        'nz': nz,
        'rho_grid': rho_grid,
        'z_grid': z_grid,
        'n_frames': n_frames,
        's2p_680_vmax': s2p_680_vmax,
        'op_833_vmax': op_833_vmax
    }


def read_colorbar_limits(filepath):
    """
    Read colorbar limits from binary file.
    
    Parameters
    ----------
    filepath : Path
        Path to colorbar_limits.bin
    
    Returns
    -------
    tuple
        (s1p_6731_vmax, s2p_680_vmax, op_833_vmax) in Rayleighs
    """
    with open(filepath, 'rb') as f:
        limits = np.fromfile(f, dtype=np.float64, count=3)
    
    return limits[0], limits[1], limits[2]


def read_emission_data(filepath, nz, nrho):
    """
    Read emission data from binary file.
    
    Parameters
    ----------
    filepath : Path
        Path to frame binary file
    nz : int
        Number of vertical grid points
    nrho : int
        Number of radial grid points
    
    Returns
    -------
    ndarray
        Emission data with shape (nz, nrho) in Rayleighs
    """
    with open(filepath, 'rb') as f:
        # Fortran writes column-major, so we read and reshape accordingly
        data = np.fromfile(f, dtype=np.float64, count=nz * nrho)
        # Reshape to (nz, nrho) - Fortran column-major matches our expected layout
        data = data.reshape((nz, nrho), order='F')
    
    return data


# =============================================================================
# PLOTTING FUNCTIONS
# =============================================================================

def save_stacked_frame(s1p_6731_data, s2p_680_data, op_833_data,
                       rho_grid, z_grid, cml_deg, output_path, limits):
    """
    Save a stacked 3-panel frame showing all three emission lines.
    
    Panel layout:
      - Top: S+ 6731 Å (optical)
      - Middle: S++ 680 Å (UV)
      - Bottom: O+ 833 Å (UV)
    
    Uses viridis colormap with smooth interpolation (gouraud shading).
    Consistent colorbar ranges across all frames.
    
    Parameters
    ----------
    s1p_6731_data : ndarray, shape (nz, nrho)
        S+ 6731 Å emission [Rayleighs]
    s2p_680_data : ndarray, shape (nz, nrho)
        S++ 680 Å emission [Rayleighs]
    op_833_data : ndarray, shape (nz, nrho)
        O+ 833 Å emission [Rayleighs]
    rho_grid : ndarray
        Array of rho positions [R_J]
    z_grid : ndarray
        Array of z positions [R_J]
    cml_deg : float
        Central Meridian Longitude [degrees]
    output_path : Path
        Output file path
    limits : dict
        Colorbar limits dictionary with keys 's1p_6731', 's2p_680', 'op_833'
    """
    RHO, Z = np.meshgrid(rho_grid, z_grid)
    
    fig, axes = plt.subplots(3, 1, figsize=FIGSIZE, sharex=True)
    
    # Define datasets with labels and limits
    datasets = [
        (s1p_6731_data, r'S$^{+}$ 6731 Å (Optical)', limits['s1p_6731']),
        (s2p_680_data, r'S$^{++}$ 680 Å (UV)', limits['s2p_680']),
        (op_833_data, r'O$^{+}$ 833 Å (UV)', limits['op_833'])
    ]
    
    for ax, (data, label, (vmin, vmax)) in zip(axes, datasets):
        cs = ax.pcolormesh(RHO, Z, data, cmap=COLORMAP, vmin=vmin, vmax=vmax, shading='gouraud')
        ax.set_ylabel('Z (R$_J$)', fontsize=11)
        ax.set_title(label, fontsize=12)
        ax.set_aspect('equal')
        plt.colorbar(cs, ax=ax, label='Brightness (R)')
    
    axes[-1].set_xlabel(r'$\rho$ (R$_J$)', fontsize=12)
    
    fig.suptitle(f'Io Plasma Torus Emission | CML = {cml_deg:.1f}°', fontsize=14, y=0.98)
    
    plt.tight_layout()
    plt.savefig(output_path, dpi=DPI, bbox_inches='tight')
    plt.close(fig)


# =============================================================================
# MAIN FUNCTION
# =============================================================================

def main():
    """Generate PNG frames from Fortran binary output."""
    
    print("=" * 70)
    print("Io Plasma Torus Emission Frame Generator")
    print("Generates PNG frames from Fortran binary output")
    print("=" * 70)
    print()
    
    # =========================================================================
    # CHECK INPUT FILES
    # =========================================================================
    
    print("Checking input files...")
    
    grid_file = INPUT_DIR / "grid_info.bin"
    limits_file = INPUT_DIR / "colorbar_limits.bin"
    
    if not grid_file.exists():
        print(f"ERROR: Grid info file not found: {grid_file}")
        print("Please run the Fortran MPI program first.")
        return
    
    if not limits_file.exists():
        print(f"ERROR: Colorbar limits file not found: {limits_file}")
        print("Please run the Fortran MPI program first.")
        return
    
    print(f"  Found: {grid_file}")
    print(f"  Found: {limits_file}")
    
    # =========================================================================
    # READ GRID AND COLORBAR INFO
    # =========================================================================
    
    print()
    print("Reading grid information...")
    
    grid_info = read_grid_info(grid_file)
    nrho = grid_info['nrho']
    nz = grid_info['nz']
    rho_grid = grid_info['rho_grid']
    z_grid = grid_info['z_grid']
    n_frames = grid_info['n_frames']
    
    print(f"  Grid: {nrho} x {nz} = {nrho * nz} points per frame")
    print(f"  rho range: {rho_grid.min():.1f} to {rho_grid.max():.1f} R_J")
    print(f"  z range: {z_grid.min():.1f} to {z_grid.max():.1f} R_J")
    print(f"  Total frames: {n_frames}")
    
    print()
    print("Reading colorbar limits...")
    
    s1p_vmax, s2p_vmax, op_vmax = read_colorbar_limits(limits_file)
    
    limits = {
        's1p_6731': (0.0, s1p_vmax),
        's2p_680': (0.0, s2p_vmax),
        'op_833': (0.0, op_vmax)
    }
    
    print(f"  S+ 6731 A:  0.0 - {s1p_vmax:.1f} R")
    print(f"  S++ 680 A:  0.0 - {s2p_vmax:.1f} R")
    print(f"  O+ 833 A:   0.0 - {op_vmax:.1f} R")
    
    # =========================================================================
    # CHECK FRAME DATA FILES
    # =========================================================================
    
    print()
    print("Checking frame data files...")
    
    missing_frames = []
    for frame_idx in range(n_frames):
        frame_str = f"{frame_idx:04d}"
        files_exist = all([
            (INPUT_DIR / f"frame_{frame_str}_s1p_6731.bin").exists(),
            (INPUT_DIR / f"frame_{frame_str}_s2p_680.bin").exists(),
            (INPUT_DIR / f"frame_{frame_str}_op_833.bin").exists()
        ])
        if not files_exist:
            missing_frames.append(frame_idx)
    
    if missing_frames:
        print(f"ERROR: Missing data for {len(missing_frames)} frames")
        print(f"  First missing: frame {missing_frames[0]}")
        return
    
    print(f"  All {n_frames} frames have complete data files")
    
    # =========================================================================
    # SETUP OUTPUT DIRECTORY
    # =========================================================================
    
    print()
    print("Setting up output directory...")
    
    if FRAME_DIR.exists():
        shutil.rmtree(FRAME_DIR)
    FRAME_DIR.mkdir(parents=True, exist_ok=True)
    
    print(f"  Created: {FRAME_DIR}")
    
    # =========================================================================
    # GENERATE FRAMES
    # =========================================================================
    
    print()
    print("=" * 70)
    print(f"Generating {n_frames} PNG frames...")
    print("=" * 70)
    print()
    
    # Calculate CML values
    cml_values = np.linspace(0, 360, n_frames, endpoint=False)
    
    for frame_idx in range(n_frames):
        frame_str = f"{frame_idx:04d}"
        cml_deg = cml_values[frame_idx]
        
        # Read emission data
        s1p_data = read_emission_data(
            INPUT_DIR / f"frame_{frame_str}_s1p_6731.bin", nz, nrho)
        s2p_data = read_emission_data(
            INPUT_DIR / f"frame_{frame_str}_s2p_680.bin", nz, nrho)
        op_data = read_emission_data(
            INPUT_DIR / f"frame_{frame_str}_op_833.bin", nz, nrho)
        
        # Generate frame
        output_path = FRAME_DIR / f"frame_{frame_str}.png"
        save_stacked_frame(s1p_data, s2p_data, op_data,
                          rho_grid, z_grid, cml_deg, output_path, limits)
        
        # Progress update
        if (frame_idx + 1) % 5 == 0 or frame_idx == 0 or frame_idx == n_frames - 1:
            print(f"  Frame {frame_idx + 1}/{n_frames} | CML = {cml_deg:.1f} deg | "
                  f"S+ max={s1p_data.max():.1f} R | S++ max={s2p_data.max():.1f} R | "
                  f"O+ max={op_data.max():.1f} R")
    
    # =========================================================================
    # SUMMARY
    # =========================================================================
    
    print()
    print("=" * 70)
    print("Frame Generation Complete!")
    print("=" * 70)
    print()
    
    n_generated = len(list(FRAME_DIR.glob("*.png")))
    print(f"Generated {n_generated} PNG frames in {FRAME_DIR}")
    print()
    print("Next step: Run make_movie_ffmpeg.py to create MP4 movie.")


# =============================================================================
# ENTRY POINT
# =============================================================================

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\nInterrupted by user.")
    except Exception as e:
        print(f"\nUnexpected error: {e}")
        import traceback
        traceback.print_exc()
