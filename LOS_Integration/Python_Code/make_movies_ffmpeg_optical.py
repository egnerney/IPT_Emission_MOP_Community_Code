#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
make_movies_ffmpeg_optical.py
==============================
Create MP4 Movies from Optical Emission Frame Sequences

This script uses FFmpeg to combine the PNG frame sequences generated by
make_emission_movie_frames_optical.py into MP4 video files.

OUTPUT MOVIES:
1. s1p_6731_emission.mp4      - S+ 6731 Å emission
2. s1p_6716_emission.mp4      - S+ 6716 Å emission
3. o1p_3729_emission.mp4      - O+ 3729 Å emission
4. stacked_emission.mp4       - Combined 3-panel stacked view

MOVIE SPECIFICATIONS:
- Frame rate: 15 fps
- Duration: 5 seconds (75 frames)
- Codec: H.264 (libx264)
- Pixel format: yuv420p (for maximum compatibility)
- CRF: 18 (high quality)

REQUIREMENTS:
- FFmpeg must be installed and available in system PATH
- Frame sequences must exist in movie_frames/ subdirectories
- Frames must be named frame_XXXX.png (4-digit zero-padded)

USAGE:
Run this script after make_emission_movie_frames_optical.py has completed:
    python make_movies_ffmpeg_optical.py

The movies will be created in the same directory as this script.

AUTHOR: Edward (Eddie) G. Nerney
INSTITUTION: LASP, University of Colorado Boulder
DATE: November 2025
LICENSE: MIT
"""

import subprocess
import sys
from pathlib import Path
import shutil

# =============================================================================
# CONFIGURATION
# =============================================================================

# Movie parameters
FRAME_RATE = 15
CRF = 18  # Quality setting (0-51, lower = better quality, 18-23 is typical)

# Frame directories (relative to script location)
FRAME_BASE = Path("movie_frames")
FRAME_DIRS = {
    's1p_6731': FRAME_BASE / "frames_s1p_6731_optical",
    's1p_6716': FRAME_BASE / "frames_s1p_6716_optical",
    'o1p_3729': FRAME_BASE / "frames_o1p_3729_optical",
    'stacked': FRAME_BASE / "frames_stacked_optical"
}

# Output movie names
OUTPUT_MOVIES = {
    's1p_6731': "s1p_6731_emission_optical.mp4",
    's1p_6716': "s1p_6716_emission_optical.mp4",
    'o1p_3729': "o1p_3729_emission_optical.mp4",
    'stacked': "stacked_emission_optical.mp4"
}

# Movie descriptions for logging
MOVIE_DESCRIPTIONS = {
    's1p_6731': "S+ 6731 Å Emission",
    's1p_6716': "S+ 6716 Å Emission",
    'o1p_3729': "O+ 3729 Å Emission",
    'stacked': "Stacked 3-Panel View"
}


# =============================================================================
# UTILITY FUNCTIONS
# =============================================================================

def check_ffmpeg():
    """
    Check if FFmpeg is available in the system PATH.
    
    Returns
    -------
    bool
        True if FFmpeg is available, False otherwise
    """
    ffmpeg_path = shutil.which("ffmpeg")
    if ffmpeg_path:
        print(f"Found FFmpeg: {ffmpeg_path}", flush=True)
        return True
    else:
        print("ERROR: FFmpeg not found in system PATH.", flush=True)
        print("Please install FFmpeg:", flush=True)
        print("  Windows: Download from https://ffmpeg.org/download.html", flush=True)
        print("           or use 'winget install ffmpeg'", flush=True)
        print("  macOS:   brew install ffmpeg", flush=True)
        print("  Linux:   sudo apt install ffmpeg", flush=True)
        return False


def count_frames(frame_dir):
    """
    Count PNG frames in a directory.
    
    Parameters
    ----------
    frame_dir : Path
        Directory containing frame images
    
    Returns
    -------
    int
        Number of PNG files found
    """
    if not frame_dir.exists():
        return 0
    return len(list(frame_dir.glob("frame_*.png")))


def create_movie(frame_dir, output_file, description):
    """
    Create an MP4 movie from a sequence of PNG frames using FFmpeg.
    
    Parameters
    ----------
    frame_dir : Path
        Directory containing frame_XXXX.png files
    output_file : str
        Output MP4 filename
    description : str
        Description for logging
    
    Returns
    -------
    bool
        True if successful, False otherwise
    """
    print(flush=True)
    print(f"Creating: {output_file}", flush=True)
    print(f"  Source: {frame_dir}", flush=True)
    print(f"  Description: {description}", flush=True)
    
    # Count frames
    n_frames = count_frames(frame_dir)
    if n_frames == 0:
        print(f"  ERROR: No frames found in {frame_dir}", flush=True)
        return False
    print(f"  Frames: {n_frames}", flush=True)
    
    # Build FFmpeg command
    # -y: Overwrite output file without asking
    # -framerate: Input frame rate
    # -i: Input pattern (frame_0000.png, frame_0001.png, etc.)
    # -vf pad: Pad to even dimensions (H.264 requires width/height divisible by 2)
    # -c:v libx264: Use H.264 codec
    # -crf: Constant Rate Factor (quality)
    # -pix_fmt yuv420p: Pixel format for compatibility
    # -preset medium: Encoding speed/quality tradeoff
    
    input_pattern = str(frame_dir / "frame_%04d.png")
    
    cmd = [
        "ffmpeg",
        "-y",                          # Overwrite without asking
        "-framerate", str(FRAME_RATE), # Input frame rate
        "-i", input_pattern,           # Input file pattern
        "-vf", "pad=ceil(iw/2)*2:ceil(ih/2)*2",  # Pad to even dimensions for H.264
        "-c:v", "libx264",             # H.264 codec
        "-crf", str(CRF),              # Quality setting
        "-pix_fmt", "yuv420p",         # Pixel format for compatibility
        "-preset", "medium",           # Encoding preset
        output_file
    ]
    
    print(f"  Running: ffmpeg -y -framerate {FRAME_RATE} -i ... -vf pad ... {output_file}", flush=True)
    
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            check=True
        )
        
        # Check output file was created
        if Path(output_file).exists():
            file_size = Path(output_file).stat().st_size / 1e6  # MB
            print(f"  Success! Output size: {file_size:.1f} MB", flush=True)
            return True
        else:
            print(f"  ERROR: Output file not created", flush=True)
            return False
            
    except subprocess.CalledProcessError as e:
        print(f"  ERROR: FFmpeg failed", flush=True)
        print(f"  stderr: {e.stderr}", flush=True)
        return False
    except Exception as e:
        print(f"  ERROR: {e}", flush=True)
        return False


# =============================================================================
# MAIN FUNCTION
# =============================================================================

def main():
    """Create all MP4 movies from frame sequences."""
    
    print("=" * 70, flush=True)
    print("Io Plasma Torus Optical Emission Movie Creator", flush=True)
    print("=" * 70, flush=True)
    print(flush=True)
    
    # =========================================================================
    # CHECK PREREQUISITES
    # =========================================================================
    
    print("Checking prerequisites...", flush=True)
    print(flush=True)
    
    # Check FFmpeg
    if not check_ffmpeg():
        return
    
    print(flush=True)
    
    # Check frame directories exist
    print("Checking frame directories...", flush=True)
    all_dirs_exist = True
    
    for name, dir_path in FRAME_DIRS.items():
        n_frames = count_frames(dir_path)
        if n_frames > 0:
            print(f"  {dir_path}: {n_frames} frames", flush=True)
        else:
            print(f"  {dir_path}: NOT FOUND or EMPTY", flush=True)
            all_dirs_exist = False
    
    if not all_dirs_exist:
        print(flush=True)
        print("ERROR: Some frame directories are missing or empty.", flush=True)
        print("Please run make_emission_movie_frames_optical.py first.", flush=True)
        return
    
    # =========================================================================
    # CREATE MOVIES
    # =========================================================================
    
    print(flush=True)
    print("=" * 70, flush=True)
    print("Creating Movies", flush=True)
    print("=" * 70, flush=True)
    
    successful = 0
    failed = 0
    
    for name in ['s1p_6731', 's1p_6716', 'o1p_3729', 'stacked']:
        frame_dir = FRAME_DIRS[name]
        output_file = OUTPUT_MOVIES[name]
        description = MOVIE_DESCRIPTIONS[name]
        
        if create_movie(frame_dir, output_file, description):
            successful += 1
        else:
            failed += 1
    
    # =========================================================================
    # SUMMARY
    # =========================================================================
    
    print(flush=True)
    print("=" * 70, flush=True)
    print("Complete!", flush=True)
    print("=" * 70, flush=True)
    print(flush=True)
    
    print(f"Movies created: {successful}", flush=True)
    if failed > 0:
        print(f"Movies failed: {failed}", flush=True)
    print(flush=True)
    
    print("Output files:", flush=True)
    for name, output_file in OUTPUT_MOVIES.items():
        if Path(output_file).exists():
            size = Path(output_file).stat().st_size / 1e6
            print(f"  {output_file} ({size:.1f} MB)", flush=True)
        else:
            print(f"  {output_file} (NOT CREATED)", flush=True)
    
    print(flush=True)
    print("Movie specifications:", flush=True)
    print(f"  Frame rate: {FRAME_RATE} fps", flush=True)
    print(f"  Duration: 5 seconds", flush=True)
    print(f"  Codec: H.264", flush=True)
    print(f"  Quality: CRF {CRF}", flush=True)
    print(f"  Filter: Padded to even dimensions", flush=True)


# =============================================================================
# ENTRY POINT
# =============================================================================

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\nInterrupted by user.", flush=True)
    except Exception as e:
        print(f"\nUnexpected error: {e}", flush=True)
        import traceback
        traceback.print_exc()
