#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
generate_frames_from_binary.py
==============================
Generate PNG Frames from Binary Emission Data

This script reads binary emission data files generated by the MPI C++ program
and creates PNG image frames showing three emission lines in a stacked 3-panel view:

    Top panel:    S+ 6731 Å (optical)
    Middle panel: S++ 680 Å (UV)
    Bottom panel: O+ 833 Å (UV)

INPUT:
Binary files in movie_data/ directory:
  - frame_XXXX.bin: Raw emission data for each frame
  - colorbar_limits.txt: Fixed colorbar limits from prescan
  - grid_info.txt: Grid dimensions and parameters

OUTPUT:
PNG frames in movie_frames/frames_stacked/ directory:
  - frame_XXXX.png: Stacked 3-panel images

USAGE:
    python3 generate_frames_from_binary.py

After running this script, use make_movies_ffmpeg.py to create the final MP4 movie.

AUTHOR: Edward (Eddie) G. Nerney
INSTITUTION: LASP, University of Colorado Boulder
DATE: November 2025
LICENSE: MIT
"""

import numpy as np
import matplotlib.pyplot as plt
from pathlib import Path
import struct
import time
import sys


# =============================================================================
# CONFIGURATION
# =============================================================================

# Input directory (from C++ program)
INPUT_DIR = Path("movie_data")

# Output directory for frames
OUTPUT_BASE = Path("movie_frames")
OUTPUT_DIR = OUTPUT_BASE / "frames_stacked"

# Figure settings
FIGURE_SIZE = (12, 10)
DPI = 150
COLORMAP = 'viridis'


# =============================================================================
# FILE I/O FUNCTIONS
# =============================================================================

def read_grid_info(filename):
    """
    Read grid information from text file.
    
    Parameters
    ----------
    filename : Path or str
        Path to grid_info.txt
    
    Returns
    -------
    dict
        Dictionary with grid parameters and arrays
    """
    info = {}
    rho_grid = []
    z_grid = []
    
    current_section = None
    
    with open(filename, 'r') as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith('#'):
                if 'rho_grid' in line:
                    current_section = 'rho'
                elif 'z_grid' in line:
                    current_section = 'z'
                continue
            
            if '=' in line:
                key, value = line.split('=')
                info[key.strip()] = int(value.strip())
            elif current_section == 'rho':
                rho_grid.append(float(line))
            elif current_section == 'z':
                z_grid.append(float(line))
    
    info['rho_grid'] = np.array(rho_grid)
    info['z_grid'] = np.array(z_grid)
    
    return info


def read_colorbar_limits(filename):
    """
    Read colorbar limits from text file.
    
    Parameters
    ----------
    filename : Path or str
        Path to colorbar_limits.txt
    
    Returns
    -------
    dict
        Dictionary with limits for each emission line
    """
    limits = {}
    
    with open(filename, 'r') as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith('#'):
                continue
            
            parts = line.split()
            if len(parts) == 3:
                name = parts[0]
                vmin = float(parts[1])
                vmax = float(parts[2])
                limits[name] = (vmin, vmax)
    
    return limits


def read_frame_binary(filename, nrho, nz):
    """
    Read emission data from binary file.
    
    File format:
      - Header: int32 nrho, int32 nz, float64 cml_deg
      - Data: nz × nrho float64 arrays for each emission line
    
    Parameters
    ----------
    filename : Path or str
        Path to binary file
    nrho : int
        Number of rho grid points
    nz : int
        Number of z grid points
    
    Returns
    -------
    tuple
        (cml_deg, s1p_6731_data, s2p_680_data, op_833_data)
        Data arrays have shape (nz, nrho)
    """
    with open(filename, 'rb') as f:
        # Read header
        file_nrho = struct.unpack('i', f.read(4))[0]
        file_nz = struct.unpack('i', f.read(4))[0]
        cml_deg = struct.unpack('d', f.read(8))[0]
        
        # Verify dimensions
        if file_nrho != nrho or file_nz != nz:
            raise ValueError(f"Dimension mismatch: file has {file_nrho}×{file_nz}, "
                           f"expected {nrho}×{nz}")
        
        # Read emission data
        n_points = nz * nrho
        s1p_6731_data = np.frombuffer(f.read(n_points * 8), dtype=np.float64).reshape(nz, nrho)
        s2p_680_data = np.frombuffer(f.read(n_points * 8), dtype=np.float64).reshape(nz, nrho)
        op_833_data = np.frombuffer(f.read(n_points * 8), dtype=np.float64).reshape(nz, nrho)
    
    return cml_deg, s1p_6731_data, s2p_680_data, op_833_data


# =============================================================================
# PLOTTING FUNCTIONS
# =============================================================================

def save_stacked_frame(s1p_6731_data, s2p_680_data, op_833_data,
                       rho_grid, z_grid, cml_deg, output_path, limits):
    """
    Save a stacked 3-panel frame showing all three emission lines.
    
    Panel layout:
      - Top: S+ 6731 Å (optical)
      - Middle: S++ 680 Å (UV)
      - Bottom: O+ 833 Å (UV)
    
    Uses viridis colormap with smooth interpolation (gouraud shading).
    Consistent colorbar ranges across all frames.
    
    Parameters
    ----------
    s1p_6731_data : ndarray, shape (nz, nrho)
        S+ 6731 Å emission [Rayleighs]
    s2p_680_data : ndarray, shape (nz, nrho)
        S++ 680 Å emission [Rayleighs]
    op_833_data : ndarray, shape (nz, nrho)
        O+ 833 Å emission [Rayleighs]
    rho_grid : ndarray
        Array of rho positions [R_J]
    z_grid : ndarray
        Array of z positions [R_J]
    cml_deg : float
        Central Meridian Longitude [degrees]
    output_path : Path
        Output file path
    limits : dict
        Colorbar limits dictionary with keys 's1p_6731', 's2p_680', 'op_833'
    """
    RHO, Z = np.meshgrid(rho_grid, z_grid)
    
    fig, axes = plt.subplots(3, 1, figsize=FIGURE_SIZE, sharex=True)
    
    # Define datasets with labels and limits
    datasets = [
        (s1p_6731_data, r'S$^{+}$ 6731 Å (Optical)', limits['s1p_6731']),
        (s2p_680_data, r'S$^{++}$ 680 Å (UV)', limits['s2p_680']),
        (op_833_data, r'O$^{+}$ 833 Å (UV)', limits['op_833'])
    ]
    
    for ax, (data, label, (vmin, vmax)) in zip(axes, datasets):
        cs = ax.pcolormesh(RHO, Z, data, cmap=COLORMAP, vmin=vmin, vmax=vmax, shading='gouraud')
        ax.set_ylabel('Z (R$_J$)', fontsize=11)
        ax.set_title(label, fontsize=12)
        ax.set_aspect('equal')
        plt.colorbar(cs, ax=ax, label='Brightness (R)')
    
    axes[-1].set_xlabel(r'$\rho$ (R$_J$)', fontsize=12)
    
    fig.suptitle(f'Io Plasma Torus Emission | CML = {cml_deg:.1f}°', fontsize=14, y=0.98)
    
    plt.tight_layout()
    plt.savefig(output_path, dpi=DPI, bbox_inches='tight')
    plt.close(fig)


# =============================================================================
# MAIN FUNCTION
# =============================================================================

def main():
    """Generate PNG frames from binary emission data."""
    
    print("=" * 70, flush=True)
    print("Io Plasma Torus Emission Frame Generator", flush=True)
    print("Binary to PNG Conversion", flush=True)
    print("=" * 70, flush=True)
    print(flush=True)
    
    # =========================================================================
    # CHECK INPUT FILES
    # =========================================================================
    
    print("Checking input files...", flush=True)
    
    grid_file = INPUT_DIR / "grid_info.txt"
    limits_file = INPUT_DIR / "colorbar_limits.txt"
    
    if not grid_file.exists():
        print(f"ERROR: Grid info file not found: {grid_file}", flush=True)
        print("Please run the MPI C++ program first.", flush=True)
        return
    
    if not limits_file.exists():
        print(f"ERROR: Colorbar limits file not found: {limits_file}", flush=True)
        print("Please run the MPI C++ program first.", flush=True)
        return
    
    # Read grid info
    grid_info = read_grid_info(grid_file)
    nrho = grid_info['nrho']
    nz = grid_info['nz']
    n_frames = grid_info['n_frames']
    rho_grid = grid_info['rho_grid']
    z_grid = grid_info['z_grid']
    
    print(f"  Grid: {nrho} × {nz} = {nrho * nz} points per frame", flush=True)
    print(f"  Frames: {n_frames}", flush=True)
    
    # Read colorbar limits
    limits = read_colorbar_limits(limits_file)
    print(f"  S+ 6731 Å limits: {limits['s1p_6731'][0]:.1f} - {limits['s1p_6731'][1]:.1f} R", flush=True)
    print(f"  S++ 680 Å limits: {limits['s2p_680'][0]:.1f} - {limits['s2p_680'][1]:.1f} R", flush=True)
    print(f"  O+ 833 Å limits:  {limits['op_833'][0]:.1f} - {limits['op_833'][1]:.1f} R", flush=True)
    
    # Count available frame files
    frame_files = sorted(INPUT_DIR.glob("frame_*.bin"))
    n_available = len(frame_files)
    
    print(f"  Binary files found: {n_available}", flush=True)
    
    if n_available == 0:
        print("ERROR: No binary frame files found.", flush=True)
        print("Please run the MPI C++ program first.", flush=True)
        return
    
    print(flush=True)
    
    # =========================================================================
    # SETUP OUTPUT DIRECTORY
    # =========================================================================
    
    print("Setting up output directory...", flush=True)
    
    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)
    print(f"  Created: {OUTPUT_DIR}", flush=True)
    print(flush=True)
    
    # =========================================================================
    # GENERATE FRAMES
    # =========================================================================
    
    print("=" * 70, flush=True)
    print(f"Generating {n_available} PNG frames...", flush=True)
    print("=" * 70, flush=True)
    print(flush=True)
    
    start_time = time.time()
    
    for idx, frame_file in enumerate(frame_files):
        frame_start = time.time()
        
        # Extract frame number from filename
        frame_num = int(frame_file.stem.split('_')[1])
        
        # Read binary data
        cml_deg, s1p_6731, s2p_680, op_833 = read_frame_binary(frame_file, nrho, nz)
        
        # Generate frame
        output_file = OUTPUT_DIR / f"frame_{frame_num:04d}.png"
        save_stacked_frame(s1p_6731, s2p_680, op_833, rho_grid, z_grid, 
                          cml_deg, output_file, limits)
        
        frame_time = time.time() - frame_start
        elapsed = time.time() - start_time
        remaining = (n_available - idx - 1) * (elapsed / (idx + 1))
        
        print(f"Frame {idx + 1:3d}/{n_available} | CML = {cml_deg:5.1f}° | "
              f"{frame_time:.2f}s | ETA: {remaining/60:.1f} min", flush=True)
    
    total_time = time.time() - start_time
    
    # =========================================================================
    # SUMMARY
    # =========================================================================
    
    print(flush=True)
    print("=" * 70, flush=True)
    print("Frame Generation Complete!", flush=True)
    print("=" * 70, flush=True)
    print(flush=True)
    
    print(f"Total time: {total_time:.1f} seconds ({total_time/60:.2f} minutes)", flush=True)
    print(f"Average time per frame: {total_time/n_available:.2f} seconds", flush=True)
    print(flush=True)
    
    n_created = len(list(OUTPUT_DIR.glob("*.png")))
    print(f"Output directory: {OUTPUT_DIR} ({n_created} frames)", flush=True)
    print(flush=True)
    
    print("Next step: Run make_movies_ffmpeg.py to create MP4 movie.", flush=True)


# =============================================================================
# ENTRY POINT
# =============================================================================

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\nInterrupted by user.", flush=True)
    except Exception as e:
        print(f"\nUnexpected error: {e}", flush=True)
        import traceback
        traceback.print_exc()
